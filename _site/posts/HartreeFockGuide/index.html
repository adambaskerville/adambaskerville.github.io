<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="T&gt;T: Hartree Fock Theory in 100 Lines" /><meta property="og:locale" content="en" /><meta name="description" content="Understanding Restricted Hartree Fock theory by developing our own simple python program." /><meta property="og:description" content="Understanding Restricted Hartree Fock theory by developing our own simple python program." /><link rel="canonical" href="https://adambaskerville.github.io/posts/HartreeFockGuide/" /><meta property="og:url" content="https://adambaskerville.github.io/posts/HartreeFockGuide/" /><meta property="og:site_name" content="Dr Adam Luke Baskerville" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-04-12T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="T&gt;T: Hartree Fock Theory in 100 Lines" /><meta name="twitter:site" content="@SciBaskerville" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-05T15:00:33+01:00","datePublished":"2020-04-12T00:00:00+01:00","description":"Understanding Restricted Hartree Fock theory by developing our own simple python program.","headline":"T&gt;T: Hartree Fock Theory in 100 Lines","mainEntityOfPage":{"@type":"WebPage","@id":"https://adambaskerville.github.io/posts/HartreeFockGuide/"},"url":"https://adambaskerville.github.io/posts/HartreeFockGuide/"}</script><title>T>T: Hartree Fock Theory in 100 Lines | Dr Adam Luke Baskerville</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dr Adam Luke Baskerville"><meta name="application-name" content="Dr Adam Luke Baskerville"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script> document.addEventListener('DOMContentLoaded', () => { const pv = document.getElementById('pageviews'); if (pv !== null) { const uri = location.pathname.replace(/\/$/, ''); const url = `https://albaskerville.goatcounter.com/counter/${encodeURIComponent(uri)}.json`; fetch(url) .then((response) => response.json()) .then((data) => { const count = data.count.replace(/\D/g, ''); pv.innerText = new Intl.NumberFormat().format(count); }) .catch((error) => { pv.innerText = '1'; }); } }); </script> <script defer src="/app.min.js?baseurl=&register=true" ></script> <script async src="https://gc.zgo.at/count.js" data-goatcounter="https://albaskerville.goatcounter.com/count" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/Baskerville_Bletchley_Crop.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Dr Adam Luke Baskerville</a><p class="site-subtitle fst-italic mb-0">Quantum Physicist <a href=https://www.kvantify.com/>@Kvantify</a></p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>T>T</span> </a><li class="nav-item"> <a href="/presentations/" class="nav-link"> <i class="fa-fw fas fa-newspaper"></i> <span>PRESENTATIONS</span> </a><li class="nav-item"> <a href="/progchem/" class="nav-link"> <i class="fa-fw fas fa-newspaper"></i> <span>PROGRAMMING COURSE</span> </a><li class="nav-item"> <a href="/publications/" class="nav-link"> <i class="fa-fw fas fa-newspaper"></i> <span>PUBLICATIONS</span> </a><li class="nav-item"> <a href="/painting/" class="nav-link"> <i class="fa-fw fas fa-newspaper"></i> <span>PAINTING</span> </a><li class="nav-item"> <a href="/astrophotography/" class="nav-link"> <i class="fa-fw fas fa-newspaper"></i> <span>ASTROPHOTOGRAPHY</span> </a><li class="nav-item"> <a href="/astro/" class="nav-link"> <i class="fa-fw fas fa-newspaper"></i> <span>ASTROPITOGRAPHY</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/adambaskerville" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/SciBaskerville" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['adamlukebaskerville','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>T>T: Hartree Fock Theory in 100 Lines</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>T>T: Hartree Fock Theory in 100 Lines</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1586646000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Apr 12, 2020 </time> </span> <span> Updated <time data-ts="1633442433" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Oct 5, 2021 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/SciBaskerville">Adam Baskerville</a> </em> </span><div> <span> <em id="pageviews"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="6233 words" > <em>34 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">T>T: Hartree Fock Theory in 100 Lines</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">T>T: Hartree Fock Theory in 100 Lines</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h1 id="try-the-code-yourself">Try the code yourself!</h1><p>Click the following button to launch an ipython notebook on Google Colab which implements the code developed in this post:</p><p><a href="https://colab.research.google.com/github/adambaskerville/adambaskerville.github.io/blob/master/_posts/HartreeFockCode/HartreeFock.ipynb" class="img-link shimmer" ><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab" loading="lazy"></a></p><p>In a previous post we looked at the <a href="https://adambaskerville.github.io/Variational-Method-Hydrogen/">hydrogen atom</a> which is an exactly solvable two-particle quantum system. If we consider a system with a nucleus and two-electrons, a three-particle system, such as the helium atom, the quantum mechanical equations can <strong>no longer be solved exactly</strong>. This poses a towering hurdle to overcome as looking at the <a href="https://www.rsc.org/periodic-table">periodic table</a> shows that every chemical element other than hydrogen contains more than 1 electron; some of them containing hundreds of electrons. If the equations of quantum mechanics cannot exactly solve any system with more than one electron then do we just throw in the towel and go solve something else? No…</p><p>We need to relax the demand for an <strong>exact</strong> solution, and instead settle for an <strong>approximate</strong> solution. Quantum physics and chemistry has been developing methods to calculate these approximate solutions for almost a century, and there are now a wide variety of sophisticated methods. If we trace back their origins we arrive at a method called <strong>Hartree Fock theory</strong> or HF for short. Hartree Fock theory provides a means of approximating the wave function and energy of a many-electron system in it’s ground state. The theory was developed in the late 1920’s but still underpins most modern many-electron electronic structure methods.</p><p>The aim of this post is to bridge the gap between Hartree Fock theory discussed in a textbook and how it is actually programmed. No published work I have seen accomplishes this and as Hartree Fock is the OG many-electron theory, it deserves a thorough guide and an appreciation of its intricacies. To start, we will discuss the theory in very simple terms before going more indepth and developing our own Hartree Fock program using just 100 lines of python code. We could make it shorter but the aim is to not compromise the readability of the code.</p><h1 id="restricted-hartree-fock-theory-made-simple">Restricted Hartree Fock Theory Made Simple</h1><p>Consider the helium atom depicted below, consisting of a central nucleus, surrounded by two electrons.</p><p><a href="/assets/img/heliumSchematic.png" class="popup img-link shimmer"><img src="/assets/img/heliumSchematic.png" alt="Desktop View" loading="lazy"></a></p><p>The reason the equations of quantum mechanics are not solvable exactly for this system is due to the interaction between the two electrons highlighted in blue which we term <strong>electron correlation</strong>. In the hydrogen atom this interaction is abscent, hence can be solved exactly. If we cannot solve helium exactly then how can we approximate it? If we look at the greatly simplified helium schematic it almost looks like two hydrogen atoms stacked on top of each other. This simple observation is at the core of Hartree Fock theory, as it is built upon one-electron operators. We take something we know, the hydrogen atom, and use them as building blocks to construct more complex atoms and molecules.</p><p>The tricky part is how to introduce the interaction between the electrons, the <strong>electron correlation</strong>. Each electron repels the other electron so that their motion is dependent on the motion of the other one. This non-separability of the electron orbits introduces the complexity into the problem, but it also suggests a possible way out. Consider one electron and disregard its instantaneous interaction with the other electron, instead imagining it to move in an average field created by the other electron. We solve the associated quantum mechanical equations and are left with a new orbital. We now switch to the other electron and repeat the process this time using the new orbital expression as our average field. We repeat this process until the results do not change. I created the following infographic to explain this procedure more clearly.</p><p><a href="/assets/img/HartreeFockInfographic.png" class="popup img-link shimmer"><img src="/assets/img/HartreeFockInfographic.png" alt="Desktop View" loading="lazy"></a></p><h1 id="restricted-hartree-fock-theory-in-detail">Restricted Hartree Fock Theory in Detail</h1><p>It is now time to develop our own Hartree Fock program. This section requires a firm knowledge in quantum mechanics and mathematics, so be prepared. From the infographic above we discuss “solving” quantum mechanical equations but it helps to know what we are actually solving; the <strong>electronic Schrödinger equation</strong>. This results from the time-independent Schrödinger equation after invoking the Born-Oppenheimer approximation</p><p>\[ \hat{H}\psi = E\psi, \tag{1} \]</p><p>where the Hamiltonian operator for the helium atom has the form</p><p>\[ \hat{H} = -\frac{1}{2}\nabla_1^2 - \frac{1}{2}\nabla_2^2 + \frac{Z}{r_1} + \frac{Z}{r_2} + {\frac{1}{r_{12}}}, \tag{2} \]</p><p>with the Born-Oppenheimer approximation invoked by removing the mass polarisation term. Let us now assume that our wavefunction is just a product of one-electron wavefunctions</p><p>\[ \psi(\mathbf{r}_1, \mathbf{r}_2) = \phi_1(\mathbf{r}_1)\phi_2(\mathbf{r}_2). \tag{3} \]</p><p>This is referred to as the <strong>Hartree product</strong> which is a sensible starting point, but this wavefunction fails to satisfy one of the most fundamental laws of quantum mechanics, <strong>the antisymmetry principle</strong>. This states that a wavefunction describing fermions should be antisymmetric (i.e. changes sign) with respect to the interchange of any set of space-spin coordinates. Textbooks tend to denote space-spin coordinates as \(\mathbf{x} = \lbrace\mathbf{r}, \omega\rbrace\) where \(\mathbf{r}\) represents the spatial degrees of freedom and \(\omega\) the spin coordinate. In most Hartree Fock applications the spin is integrated off early on in the process as it can make things annoyingly complicated later on. Introducing these space-spin coordinates into our Hartree product gives</p><p>\[ \psi(\mathbf{x}_1, \mathbf{x}_2) = \chi_1(\mathbf{x}_1)\chi_2(\mathbf{x}_2), \tag{4} \]</p><p>where we have also substituted spin orbitals, \(\chi(\mathbf{x})\) in place of the spatial orbitals \(\phi(\mathbf{r})\). This still fails to satisfy the antisymmetry principle which we now demonstrate. Consider switching the position of the two electrons, \(1 \leftrightarrow 2\)</p><p>\[ \psi(\mathbf{x}_2, \mathbf{x}_1) = \chi_1(\mathbf{x}_2)\chi_2(\mathbf{x}_1). \tag{5} \]</p><p>The sign of the wavefunction has not changed, thus it is an incorrect wavefunction. We now introduce the Fock into our Hartree Fock method with the use of <strong>Slater determinants</strong>. A Slater determinant is a determinant of spin orbitals which represents an antisymmetrised wavefunction. For the helium atom this looks like</p><p>\[ \psi(\mathbf{x}_1, \mathbf{x}_2) = \frac{1}{\sqrt{2!}} \begin{vmatrix} \chi_1(\mathbf{x}_1) &amp; \chi_2(\mathbf{x}_1) \\<br /> \chi_1(\mathbf{x}_2) &amp; \chi_2(\mathbf{x}_2) \end{vmatrix}. \tag{6} \]</p><p>By expanding this determinant we get the following wavefunction form</p><p>\[ \psi(\mathbf{x}_1, \mathbf{x}_2) = \frac{1}{\sqrt{2}} \left[\chi_1(\mathbf{x}_1)\chi_2(\mathbf{x}_2) - \chi_2(\mathbf{x}_1)\chi_1(\mathbf{x}_2) \right], \tag{7} \]</p><p>which is just a linear combination of the possibilities and does obey the antisymmetry principle. Another consequence of forming the Slater determinant is that if any two rows or columns are identical then the determinant is zero. This shows that the wavefunction dissapears if two electrons have the same quantum numbers, required by the <strong>Pauli exclusion principle</strong> which is a consequence of the antisymmetry principle.</p><h2 id="hartree-fock-equation"><span class="me-2">Hartree Fock Equation</span><a href="#hartree-fock-equation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As discussed earlier, Hartree Fock theory is built upon one-electron operators with each electron considered to move in the electrostatic field of the nuclei and the average field of the \(N-1\) electrons. One of these one electron operators acts on an orbital to produce an orbital energy and associated orbital wavefunction. The following represents the Hartree Fock equation for a spin orbital, \(\chi_i\), occupied by electron 1</p><p>\[ f(\mathbf{x_1})\chi_i(\mathbf{x_1}) = \epsilon_i\chi_i(\mathbf{x_1}). \tag{8} \]</p><p>with \(f(\mathbf{x_1})\) representing the one-electron Fock operator and \(\epsilon_i\) the one-electron orbital energy. By integrating out the spin, we are left with the closed-shell <strong>spatial</strong> Hartree Fock equation</p><p>\[ f(\mathbf{r_1})\psi_i(\mathbf{r_1}) = \epsilon_j\psi_i(\mathbf{r_1}). \tag{9} \]</p><p>Note, the energy of the spin orbital, \({\epsilon_i}\) is equal to the energy of the spatial orbital, \(\epsilon_j\). This equation is just a simple eigenvalue equation, where the Fock operator, \(f(\mathbf{r_1})\) acts on the spatial function, \(\psi_i(\mathbf{r_1})\) to produce eigenvalues, \(\epsilon_j\). This highlights that the Fock operator is an effective one-electron operator, as it acts on a one-electron function. The Fock operator has the form</p><p>\[ f(\mathbf{r_1}) = h(\mathbf{r_1}) + \sum_{a}^{N/2}\int \psi_a^*(\mathbf{r_2})(2-P_{12})r_{12}^{-1}\psi_a(\mathbf{r_2})\text{d}\mathbf{r_2}, \tag{10} \]</p><p>where \(P_{12}\) represents the parity operator. A more convenient and recognisable form is</p><p>\[ f(1) = h(1) + \sum_{a}^{N/2}2J_a(1) - K_a(1), \tag{11} \]</p><p>The Fock operator contains all the relevant interactions between particles, with terms defined as follows:</p><ul><li>\(f(1)\): Fock operator<li>\(h(1)\): Nucleus-electron kinetic energy and potential attraction to all nuclei<li>\(J_a(1)\): Coulomb operator -&gt; Electron-electron repulsion<li>\(K_a(1)\): Exchange operator -&gt; Electron-electron exchange</ul><p>There are two electrons in each orbital forming \(N\) total electrons. The sum is over the \(N/2\) <strong>occupied orbitals</strong>, \(\psi_a\). The closed-shell Coulomb operator, \(J\) and exchange operator, \(K\) have the following forms</p><p>\[ J_a(1) = \int \psi_a^*(2)r_{12}^{-1}\psi_a(2)\text{d}\mathbf{r_2}, \tag{12} \]</p><p>\[ K_a(1)\psi_i(1) =\left[\int \psi_a^*(2)r_{12}^{-1}\psi_i(2)\text{d}\mathbf{r_2}\right]\psi_a(1). \tag{13} \]</p><p>The exchange operator is a purely quantum mechanical entity with no classical analogue, hence must act on a wavefunction. In its current state, this mathematics will be cumbersome to program on a computer; so lets write it in a form that it can better understand, using the language of <strong>matrices</strong>.</p><h2 id="roothaan-hall-equations"><span class="me-2">Roothaan-Hall Equations</span><a href="#roothaan-hall-equations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This is where Restricted Hartree Fock begins from a computational standpoint. Equation (9) represents a complicated integro-differential equation, meaning it involves both integrals and derivatives of a function. Roothaan and Hall independently showed that by introducing a set of known spatial basis functions, the differential equation could be converted to a set of algebraic equations. This meant that standard matrix techniques could be used to achieve a solution.</p><p>This is more like it! Computers and matrices were made for each other, and the complicated integro-differential equation transforms into a much simpler matrix equation</p><p>\[ \mathbf{F}\mathbf{C} = \mathbf{S}\mathbf{C}\boldsymbol{\epsilon}, \tag{14} \]</p><p>where \(\mathbf{F}\) represents the Fock matrix, \(\mathbf{C}\) is a \(K \times K\) square matrix of the expansion coefficients, \(\mathbf{S}\) is the overlap matrix and \(\boldsymbol{\epsilon}\) is a diagonal matrix of the orbital energies, \(\epsilon_i\). The overlap matrix, \(\mathbf{S}\) is required as basis sets are not usually orthonormal sets. The basis functions tend to be normalised, but they are not always orthogonal to each other. In order to write the Roothaan-Hall equations in the form of a matrix eigenvalue problem, the basis needs to be orthogonalised; so for basis functions that are not orthogonal, we include the \(\mathbf{S}\) matrix in order to ensure the orthonormality. The overlap matrix elements have the following form</p><p>\[ S_{\mu \nu} = \int \phi_\mu^*(\mathbf{r})\phi_\nu(\mathbf{r})\text{d}\mathbf{r}. \tag{15} \]</p><p>The Roothan-Hall equations cannot be solved directly because the Fock matrix depends on the Coulomb and exchange integrals which depend on the spatial wavefunction meaning there is an inter-dependency issue. We thus follow a Self Consistent Field (SCF) procedure where new coefficients \(C_{ij}\) are obtained each iteration, continuing until the convergence criteria has been met. We now introduce the <strong>charge density matrix</strong> which we will use to calculate the Fock matrix, \(\mathbf{F}\).</p><h2 id="charge-density-matrix"><span class="me-2">Charge Density Matrix</span><a href="#charge-density-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A charge density matrix is a probability distribution function of an electron, described by a spatial function, \(\psi_a(r)\). The probability of finding this electron in a volume element \(\text{d}\mathbf{r}\) at a point \(\mathbf{r}\) is simply \(\lvert\psi_a(r)\rvert^2 \text{d}\mathbf{r}\), which in turn means the probability distribution function is \(\lvert\psi_a(r)\rvert^2\).</p><p>For the Closed-shell Hartree Fock problem, described by a single determinant wave function with all orbitals doubly occupied, the total charge density is given by</p><p>\[ \rho(\mathbf{r}) = 2\sum\limits_{a}^{N/2}|\psi_a(\mathbf{r})|^2. \tag{16} \]</p><p>The probability of finding any electron in the volume element, \(\text{d}\mathbf{r}\) at \(\mathbf{r}\) is \(\rho (r) \text{d}\mathbf{r}\). We can also calculate the total number of electrons by integrating the charge density</p><p>\[ \int \rho (\mathbf{r})\text{d}\mathbf{r} = 2\sum\limits_{a}^{N/2}\int|\psi_a(\mathbf{r})|^2 \text{d}\mathbf{r} = 2\sum\limits_{a}^{N/2}1 = N, \tag{17} \]</p><p>assuming \(\psi_a(\mathbf{r})\) normalises to one. For a single determinant, the total charge density is just the sum of the charge densities for each of the electrons.</p><p>Now insert a generic orbital expression, \(\psi_a(\mathbf{r}) = \sum C\phi(\mathbf{r})\) into equation (16). The function, \(\phi(\mathbf{r})\) represents the basis function you want, e.g. exponential function, Hermite polynomial etc… and \(C\) represents the weighting coefficient of that particular function, i.e. how much it contributes to the total wavefunction, \(\psi_a(\mathbf{r})\).</p><p>\[ \begin{aligned} \rho(\mathbf{r}) &amp; = 2\sum\limits_{a}^{N/2}\psi_{a}^* (\mathbf{r})\psi_a(\mathbf{r}) \\<br /> &amp; = 2 \sum\limits_{a}^{N/2}\sum\limits_{\nu}C_{\nu a}^* \phi_{\nu} ^* (\mathbf{r})\sum\limits_{\mu}C_{\mu a}\phi_\mu(\mathbf{r}) \\<br /> &amp; = \sum\limits_{\mu \nu}P_{\mu\nu}\phi_{\mu}(\mathbf{r})\phi_{\nu} ^*(\mathbf{r}) \end{aligned} \tag{18} \]</p><p>where \(P_{\mu\nu}\) represents the matrix elements of the charge density matrix, \(\mathbf{P}\)</p><p>\[ P_{\mu\nu} = 2\sum\limits_{a}^{N/2} C_{\mu a}C_{\nu a}^*. \tag{19} \]</p><p>The charge density matrix is built using the coefficients of the basis set, and given a set of basis functions, \({\phi_\mu }\), the matrix \(\mathbf{P}\) specifies the charge density, \(\rho(\mathbf{r})\) of the electrons in your system. If we look back at our Fock matrix expression, equation (11), and introduce this basis \({\phi_\mu}\), we get</p><p>\[ \begin{aligned} F_{\mu\nu} &amp; = \int \phi_{\mu}^* (1)f(1)\phi_\nu(1)\text{d}\mathbf{r_{1}} \\<br /> &amp; =\int \phi_{\mu}^* (1)h(1)\phi_{\nu}(1)\text{d}\mathbf{r_{1}} + \sum\limits_{a}^{N/2}\int\phi_{\mu}^* (1)[2J_a (1) - K_a (1)]\phi_{\nu}(1)\text{d}\mathbf{r_{1}} \\<br /> &amp; =H_{\mu\nu}^\text{core} + \sum\limits_{a}^{N/2} 2(\mu\nu\lvert aa) - (\mu a\lvert a\nu) \end{aligned} \tag{20} \]</p><p>where \((\mu\nu\lvert aa)\) is shorthand notation for a two-electron integral. Our choice of wavefunction will involve some form of linear expansion given by</p><p>\[ \psi_i = \sum\limits_{\mu=1}^{K} C_{\mu i}\phi_\mu, \hspace{1cm} i =1,2,\ldots,K. \tag{21} \]</p><p>We now insert this expansion into the two-electron terms giving us our final expression for the Fock matrix</p><p>\[ \begin{aligned} F_{\mu\nu} &amp; = H_{\mu\nu}^\text{core} + \sum\limits_{a}^{N/2}\sum\limits_{\lambda\sigma}C_{\lambda a}C_{\sigma a}^* [2(\mu\nu|\sigma\lambda) - (\mu\lambda|\sigma\nu)] \\<br /> &amp; = H_{\mu\nu}^\text{core} + \sum\limits_{\lambda\sigma} P_{\lambda\sigma}[(\mu\nu|\sigma\lambda) - \frac{1}{2}(\mu\lambda|\sigma\nu)] \\<br /> &amp; = H_{\mu\nu}^\text{core} + G_{\mu\nu}, \end{aligned} \tag{22} \]</p><p>where \(G_{\mu\nu}\) is the two-electron part of the Fock matrix.</p><p>This all seems very complicated but we have now discussed all the elements we need, so lets start our program and learn on the job. We start with an overview of the Hartree Fock procedure our program should follow.</p><h1 id="the-hartree-fock-procedure">The Hartree Fock Procedure</h1><p>The Hartree Fock process is as follows:</p><ol><li><p>Specify system and basis set</p><li><p>Calculate one and two-electron integrals</p><li><p>Diagonalise the overlap matrix, \(\mathbf{S}\) to obtain a transformation matrix, \(\mathbf{X} \equiv \mathbf{S} ^{−1/2}\)</p><li><p>Provide initial guess as to the density matrix, \(\mathbf{P}\).</p><li><p>Calculate \(\mathbf{G}\) matrix (\(\mathbf{G} = 2\mathbf{J} - \mathbf{K}\)) using \(\mathbf{P}\) and the two-electron integrals</p><li><p>Obtain Fock matrix from sum of the core Hamiltonian matrix and \(\mathbf{G}\) matrix, \(\mathbf{F} = \mathbf{H}^\text{core} + \mathbf{G}\)</p><li><p>Calculate transformed Fock matrix, \(\mathbf{F}’ = \mathbf{X}^\dagger \mathbf{F}\mathbf{X}\)</p><li><p>Diagonalise \(\mathbf{F}’\) to obtain \(\mathbf{C}’\)</p><li><p>Calculate the coefficient matrix using, \(\mathbf{C} = \mathbf{X} \mathbf{C}’\)</p><li><p>These coefficients form the new density matrix, \(\mathbf{P}\)</p><li><p>Determine convergence of the density matrix, by comparing the new density matrix with the old density matrix within a specified criterion. If the convergence has not been met then return to step (5) with the new density matrix \(\mathbf{P}\) to form a new Fock matrix and repeat</p><li><p>If convergence has been met then end the SCF cycle and return desired quantities, e.g. Energy, coefficient matrix.</p></ol><p>This process looks more difficult than it actually is. Hartree Fock theory is a wavefunction based method, meaning a wavefunction form needs to first be selected and the associated one and two-electron integrals calculated. A nice example of restricted Hartree Fock theory is given in Lewars\(^{[2]}\) for protonated helium, H-He\(^+\). This system will be borrowed as it represents some benchmark data for our own program to replicate.</p><h2 id="1-specify-system-and-basis-set"><span class="me-2">1) Specify system and basis set</span><a href="#1-specify-system-and-basis-set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The basis set for this example will be the STO-1G basis set, meaning Slater-Type Orbitals-1 Gaussian, i.e. approximating a slater-type 1s orbital with a Gaussian function. The STO-1G approximations used for the hydrogen and helium 1s orbitals in a molecular environment are</p><p>\[ \begin{aligned} \phi(\text{H}) &amp;= \phi_1 = 0.3696 \text{exp}(-0.4166|\mathbf{r} - \mathbf{R_1}|^2), \\<br /> \phi(\text{He}) &amp;= \phi_2 = 0.5881 \text{exp}(-0.7739|\mathbf{r} - \mathbf{R_2}|^2), \end{aligned} \]</p><p>where \(\lvert\mathbf{r} − \mathbf{R_i} \rvert\) is the distance of the electron in \(\phi_ 1\) from nucleus, \(i\) on which \(\phi_i\) is centred. The multiplicity of this singlet ground state (number of unpaired electron spins) is</p><p>\[ \text{Multiplicity = 2s + 1,} \]</p><p>where \(s\) is the total number of unpaired electron spins; so for the singlet ground state with paired electron spins, Multiplicity = 1.</p><h2 id="2-calculate-one-and-two-electron-integrals"><span class="me-2">2) Calculate One and Two-Electron Integrals</span><a href="#2-calculate-one-and-two-electron-integrals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Calculation of one and two-electron integrals are dependent on the wavefunction form so their calculation is specific to the selected basis; and there is not a completely generic calculation route.</p><h3 id="one-electron-integrals"><span class="me-2">One-Electron Integrals</span><a href="#one-electron-integrals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>One-electron integrals make up the core Hamiltonian matrix. This contains the interaction between the nucleus and each electron in the absence of electron-electron interaction.</p><p><strong>Kinetic Energy:</strong></p><p>\[ T_{rs}(1) = \int\phi_r\left(-\frac{1}{2}\nabla_1^2\right)\phi_s\text{d}\nu. \tag{23} \]</p><p><strong>Potential Energy Integral for hydrogen atom, H:</strong></p><p>\[ V_{rs}(\text{H},1) = \int\phi_{r}\left(\frac{Z_\text{H}}{r_{\text{H} 1}}\right)\phi_s\text{d}\nu. \tag{24} \]</p><p><strong>Potential Energy Integral for helium atom, He:</strong></p><p>\[ V_{rs}(\text{He},1) = \int\phi_r\left(\frac{Z_\text{He}}{r_{\text{He}1}}\right)\phi_s\text{d}\nu. \tag{25} \]</p><p>where \(r_{\text{H}1}\) represents the distance of an electron from the hydrogen nucleus and \(r_{\text{He}1}\) represents the distance of an electron from the helium nucleus. Substitute the hydrogen and helium orbitals into these expressions to calculate the one-electron integrals. This can be done using Mathematica, Maple etc…</p><p>\[ \begin{aligned} T_{11} &amp;= 0.6429 \\<br /> T_{12} &amp;= T_{21} = 0.2395 \\<br /> T_{22} &amp;= 1.1609\\<br /> V_{11}(\text{H}) &amp;= -1.0300\\<br /> V_{12}(\text{H}) &amp;= V_{21}(\text{H}) = -0.4445\\<br /> V_{22}(\text{H}) &amp;= 1.1609\\<br /> V_{11}(\text{He}) &amp;= -1.2555\\<br /> V_{12}(\text{He}) &amp;= V_{21}(\text{He}) = -1.1110\\<br /> V_{22}(\text{He}) &amp;=-2.8076 \end{aligned} \]</p><h3 id="two-electron-integrals"><span class="me-2">Two-Electron Integrals</span><a href="#two-electron-integrals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Two-electron integrals are the major bottleneck with any Hartree Fock program, so a good practice is to precompute all of them beforehand and use a lookup table when building the Fock matrix. A two-electron integral has the general form</p><p>\[ (rs|tu) = \int \phi_r\phi_s \frac{1}{r_{12}}\phi_t\phi_u\text{d}V. \tag{26} \]</p><p>where \(\phi_{r,s,t,u}\) represent the chosen basis functions, and \(1/r_{12}\) the reciprocal of the inter-electronic distance, integrated over all space, \(\text{d}V\). These two-electron integrals will be used to form the \(\mathbf{G}\) matrix, which is simply the contribution from the Coulomb and exchange operators in the Fock matrix, i.e.</p><p>\[ G_{rs} = \sum\limits_{t=1}^{m}\sum\limits_{u=1}^{m} P_{tu}\left[(rs|tu) - \frac{1}{2}(ruts)\right] \tag{27} \]</p><p>where \(P_{tu}\) represents an element from the density matrix. For clarity, consider the matrix element, \(G_{11}\)</p><p>\[ G_{11} = \sum_{t=1}^{m}\sum_{u=1}^{m}P_{tu}\left[(11|tu) -\frac{1}{2}(1u|t1)\right]. \tag{28} \]</p><p>i.e.</p><p>\[ \begin{aligned} G_{11} &amp;= \sum_{t=1}^{2}\left[P_{t1}\left[(11|t1) - \frac{1}{2}(11|t1)\right]+P_{t2}\left[(11 \lvert t2)-\frac{1}{2}(12|t1)\right]\right] \\<br /> &amp;= P_{11}\left[(11 \lvert 11)-\frac{1}{2}(11 \lvert 11)\right] + P_{12}\left[(11 \lvert 12)-\frac{1}{2}(12 \lvert 11)\right] \\<br /> &amp;+ P_{21}\left[(11 \lvert 21)-\frac{1}{2}(11 \lvert 21)\right] + P_{22}\left[(11 \lvert 22)-\frac{1}{2}(12 \lvert 21)\right]. \end{aligned} \tag{29} \]</p><p>The same is done for \(G_{12}\) = \(G_{21}\) and \(G_{22}\). Each element of the electron repulsion matrix, \(\mathbf{G}\) has 8, two-electron repulsion integrals, totalling 32 integrals. Of these only 14 are different.</p><p>\[ \begin{aligned} &amp;\text{from}\ G_{11}: (11|11), (11|12), (12|11), (11|21), (11|22), (12|21) \\<br /> &amp;\text{new from } G_{12}=G_{21}: (12|12), (12|22) \\<br /> &amp;\text{new from } G_{22}: (22|11), (21|12), (22|12), (22|21), (21|22), (22|22) \end{aligned} \tag{30} \]</p><p>Many of these 14 combinations are not unique and obey an 8-fold permutation symmetry</p><p>\[ (rs|tu) = (rs|ut) = (sr|tu) = (sr|ut) = (tu|rs) = (tu|sr) = (ut|rs) = (ut|sr). \]</p><p>In general, the number of <strong>unique</strong> two-electron integrals can be calculated by analysing the number of unique indices</p><ul><li>Four unique indices, \(r\ne s\ne t\ne u\implies 3\binom{m}{4}\)<li>Three unique indices, e.g. \({r\ne s\ne t= u\implies 6\binom{m}{3}}\)<li>Two unique indices, e.g. \({r\ne s= t= u\implies 4\binom{m}{2}}\)<li>Zero unique indices, \({r= s= t= u\implies 1\binom{m}{1}}\)</ul><p>These add to give a total of \({m(m+1)(m^2+m+2)/8}\) two-electron integrals. There are only 6 <strong>unique</strong> two-electron repulsion integrals for our example which is a lot better than calculating 32.</p><p>\[ \begin{matrix} (11|11) = 0.7283 &amp; (21|21) = 0.2192 \\<br /> (21|11) = 0.3418 &amp; (22|21) = 0.4368 \\<br /> (22|11) = 0.5850 &amp; (22|22) = 0.9927 \end{matrix} \]</p><p>The integrals, \((11 \lvert 11)\) and \((22 \lvert 22)\) represent repulsion between electrons in the same orbital, (\({\phi_1}\) and \({\phi_2}\) respectively) whereas the integral \({(22 \lvert 11)}\) represents repulsion between an electron in \({\phi_2}\) and one in \({\phi_1}\). The integral \((21 \lvert 11)\) can be regarded as representing the repulsion between an electron associated with \({\phi_2}\) and \({\phi_1}\) and one confined to \({\phi_1}\).</p><p>Now we have the one and two-electron integrals we can load these into the program, which we will do using separate text files. This means that the main program does not need to be modified everytime a new basis set is to be used. These integral files are given below, <code class="language-plaintext highlighter-rouge">enuc.dat</code> contains the nuclear repulsion value (classical term) which is calculated as</p><p>\[ V_{NN} = \frac{Z_{\text{He}}Z_{\text{H}}}{r_{\text{HeH}}} = \frac{1 \times 2}{1.5117}\ \text{hartrees} = 1.3230\ \text{hartrees}, \]</p><p>where we have selected the inter-nuclear separation, \(r_{\text{HeH}}\) to be \(0.8\ \text{angstroms} \equiv 1.5117 a_{0}\). <code class="language-plaintext highlighter-rouge">tint.dat</code> contains the one-electron kinetic energy integrals, <code class="language-plaintext highlighter-rouge">vint.dat</code> contains the one-electron potential energy integrals, <code class="language-plaintext highlighter-rouge">sint.dat</code> contains the overlap integrals and <code class="language-plaintext highlighter-rouge">twoelecint.dat</code> contains the two-electron integrals referenced by their unique 4 index \((rs \lvert tu)\). Copy these data into your own text files and save in a directory where your RHF program will reside.</p><h2 id="enucdat"><span class="me-2">enuc.dat</span><a href="#enucdat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>1.3230 
</pre></table></code></div></div><h2 id="tintdat"><span class="me-2">tint.dat</span><a href="#tintdat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>1     1   0.6249
2     1   0.2395
2     2   1.1609
</pre></table></code></div></div><h2 id="vintdat"><span class="me-2">vint.dat</span><a href="#vintdat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>1     1  -2.2855
2     1  -1.5555 
2     2  -3.4639
</pre></table></code></div></div><h2 id="sintdat"><span class="me-2">sint.dat</span><a href="#sintdat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>1     1    1.0000
2     1    0.5017
2     2    1.0000
</pre></table></code></div></div><h2 id="twoelecintdat"><span class="me-2">twoelecint.dat</span><a href="#twoelecintdat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>2     2     2     2     0.9927
2     2     2     1     0.4368
2     1     2     1     0.2192
2     2     1     1     0.5850
2     1     1     1     0.3418
1     1     1     1     0.7283
</pre></table></code></div></div><h3 id="3-diagonalise-overlap-matrix"><span class="me-2">3) Diagonalise Overlap Matrix</span><a href="#3-diagonalise-overlap-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Why do we need to diagonalise the overlap matrix? This goes back to a point discussed earlier, that basis sets are not commonly orthonormal sets. The basis functions are normalised, but they are not orthogonal to each other. In order to write Roothaan’s equations in the form of a matrix eigenvalue problem, the basis needs to be orthogonalised. For basis functions that are not orthogonal we need to introduce the overlap matrix</p><p>\[ S_{\mu \nu} = \int \phi_\mu^*(\mathbf{r})\phi_\nu(\mathbf{r})\text{d}\mathbf{r}. \tag{31} \]</p><p>It will always be possible to find a transformation matrix, \(\mathbf{X}\) such that a transformed set of functions given by</p><p>\[ \phi_\mu’ = \sum X_{\nu \mu}\phi_\nu, \hspace{0.5cm} \mu = 1,2,\ldots,K, \tag{32} \]</p><p>do form an orthonormal set, i.e.</p><p>\[ \int \phi_\mu’^*(\mathbf{r})\phi_\nu’(\mathbf{r})\text{d}\mathbf{r} = \delta_{\mu\nu}. \tag{33} \]</p><p>The transformation matrix \(\mathbf{X}\) must satisfy the following condition</p><p>\[ \mathbf{X}^\dagger\mathbf{S}\mathbf{X} = 1, \tag{34} \]</p><p>for the transformed orbitals to form an orthonormal set. So how do we enforce this relation? There are two conventional ways of doing this:</p><p>1) Symmetric orthogonalisation</p><p>2) Canonical orthogonalisation</p><p>In this post we will consider the first of these options, symmetric orthogonalisation, which uses the inverse square root of the overlap matrix, \(\mathbf{S}^{-1/2}\) as the transformation matrix, \(\mathbf{X}\). To find \(\mathbf{S}^{-1/2}\) we need to diagonalise the overlap matrix</p><p>\[ \mathbf{s} = \mathbf{U}^\dagger\mathbf{S}\mathbf{U}, \tag{35} \]</p><p>where \(\mathbf{s}\) is the diagonal matrix of eigenvalues. We then take the inverse square root of each of these eigenvalues to form \(\mathbf{s}^{-1/2}\). Doing this transformation has moved us out of our original basis so we need to “back transform” to the original basis by doing the following</p><p>\[ \mathbf{X} = \mathbf{S}^{-1/2} = \mathbf{U}\mathbf{s}^{-1/2}\mathbf{U}^\dagger. \tag{36} \]</p><p>This transformation matrix \(\mathbf{X}\) should now satisfy equation (34). Diagonalising a matrix is easy in python using numpy:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1"># Diagonalize overlap matrix 
# SVAL are eigenvalues of overlap matrix
# SVEC are eigenvectors of overlap matrix
</span><span class="n">SVAL</span><span class="p">,</span> <span class="n">SVEC</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">eigh</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> 
</pre></table></code></div></div><p>Calculating the inverse square root of the eigenvalues is done using the following:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1"># Find inverse square root of eigenvalues 
</span><span class="n">SVAL_minhalf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">diag</span><span class="p">(</span><span class="n">SVAL</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)))</span>
</pre></table></code></div></div><p>We form the transformation matrix, \(\mathbf{X} = \mathbf{S}^{-1/2}\) using the following:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1"># Form the transformation matrix X, S_minhalf
</span><span class="n">S_minhalf</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">SVEC</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">SVAL_minhalf</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">SVEC</span><span class="p">)))</span>
</pre></table></code></div></div><h3 id="4-initial-guess-for-density-matrix-mathbfp"><span class="me-2">4) Initial Guess for Density matrix, \(\mathbf{P}\)</span><a href="#4-initial-guess-for-density-matrix-mathbfp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In order to build the Fock matrix, an initial guess for the charge density matrix \(\mathbf{P}\) is needed. The simplest guess would be the zero matrix which is equivalent to approximating \(\mathbf{F}\) as the core Hamiltonian matrix; neglecting all electron-electron interactions in the first iteration.</p><h3 id="5-calculate-mathbfg-matrix"><span class="me-2">5) Calculate \(\mathbf{G}\) matrix</span><a href="#5-calculate-mathbfg-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The \(\mathbf{G}\) matrix is the contribution from the Coulomb and exchange operators in the Fock matrix, i.e. the average electrostatic repulsion between electrons. These two operators involve the two-electron integrals which we calculated above so lets discuss how to build these matrices in python. First we need to load the two-electron integral values from our text file <code class="language-plaintext highlighter-rouge">twoelecint.dat</code>. This can be done in numerous ways but for this example using <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html">genfromtxt</a> is a good option:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1"># Load Two Electron Integrals (TEI) from file
</span><span class="n">TEI</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="sh">'</span><span class="s">./two_elec_int.dat</span><span class="sh">'</span><span class="p">)</span> 
</pre></table></code></div></div><p>We now need a means of accessing particular two electron integrals to build our Fock matrix. For this example this is very simple but I will describe a more sophisticated technique which is vital for more complicated systems.</p><p>There are only 6 <strong>unique</strong> two-electron integrals for our protonated helium example, but what if we had thousands, millions of them? Computer memory can sometimes be an issue when storing and accessing these integrals and it is bad practice to load millions of two-electron integrals into Random Access Memory (RAM) at once. A lot of algorithms also do not calculate two electron integrals in order, so how do we order them so they can be read sequentially, speeding up Fock matrix formation? We use a <a href="https://en.wikipedia.org/wiki/Yoshimine_sort"><strong>Yoshimine sort</strong></a> algorithm which transforms a 4-index into a single compound index. This was developed by M. Yoshimine to order long lists of data.</p><p>The Yoshimine sort can be programmed in python as follows:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">eint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Return compound index given four indices using Yoshimine sort
    </span><span class="sh">'''</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> 
        <span class="n">ab</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">ab</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span> 
        <span class="n">cd</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">cd</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">ab</span> <span class="o">&gt;</span> <span class="n">cd</span><span class="p">:</span> 
        <span class="n">abcd</span> <span class="o">=</span> <span class="n">ab</span><span class="o">*</span><span class="p">(</span><span class="n">ab</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cd</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">abcd</span> <span class="o">=</span> <span class="n">cd</span><span class="o">*</span><span class="p">(</span><span class="n">cd</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ab</span>

    <span class="k">return</span> <span class="n">abcd</span>
</pre></table></code></div></div><p>We now run our list of two-electron integrals through this sorting algorithm and place them in a dictionary for easy access:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1"># Apply Yoshimine sort to the two-electron integrals, TEI.
</span><span class="n">twoe</span> <span class="o">=</span> <span class="p">{</span><span class="nf">eint</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TEI</span><span class="p">}</span>
</pre></table></code></div></div><p>We can now see how the Yoshimine sort transforms the indices into a new compound index.</p><p><strong>Original lookup table:</strong></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>2     2     2     2     0.9927
2     2     2     1     0.4368
2     1     2     1     0.2192
2     2     1     1     0.5850
2     1     1     1     0.3418
1     1     1     1     0.7283
</pre></table></code></div></div><p><strong>Yoshimine dictionary:</strong></p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="mf">20.0</span><span class="p">:</span> <span class="mf">0.9927</span><span class="p">,</span> <span class="mf">19.0</span><span class="p">:</span> <span class="mf">0.4368</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">:</span> <span class="mf">0.2192</span><span class="p">,</span> <span class="mf">17.0</span><span class="p">:</span> <span class="mf">0.585</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">:</span> <span class="mf">0.3418</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">:</span> <span class="mf">0.7283</span><span class="p">}</span>
</pre></table></code></div></div><p>We now define a function to <code class="language-plaintext highlighter-rouge">get</code> specific two-electron integral values from our dictionary by still referencing the 4-indices, \(a,\ b,\ c,\ d\):</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">tei</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Return value of two electron integral
    </span><span class="sh">'''</span>
    <span class="k">return</span> <span class="n">twoe</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nf">eint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> 
</pre></table></code></div></div><p>A single element of the \(\mathbf{G}\) matrix is now calculated as:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1"># Calculate G matrix, 2J - K. 1 is added to the indices due to python's 0 indexing scheme
</span><span class="nf">tei</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="nf">tei</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">######## J #########       ######## K ######### 
</span></pre></table></code></div></div><p>We can now use this expression to build the entire Fock matrix by wrapping it in a loop structure.</p><h3 id="6-calculate-fock-matrix-mathbff"><span class="me-2">6) Calculate Fock matrix, \(\mathbf{F}\)</span><a href="#6-calculate-fock-matrix-mathbff" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A simple way to construct a Fock matrix is to just loop over each basis index, accessing every two-electron integral and assigning their place in the Fock matrix. This requires quadruple nested <code class="language-plaintext highlighter-rouge">for</code> loops which are usually advised against but is suitable for this example.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">makefock</span><span class="p">(</span><span class="n">Hcore</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Build the Fock Matrix

    Hcore : Core Hamiltonian matrix
    P     : Density matrix
    dim   : The dimension of the problem, i.e. the number of basis functions
    </span><span class="sh">'''</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="c1"># Build zero array to append to
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hcore</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="c1"># Set initial Fock matrix as core Hamiltonian matrix
</span>            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                    <span class="c1"># Form the Fock matrix using the product of the density matrix and G matrix
</span>                    <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nf">tei</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="nf">tei</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Return Fock matrix
</span>    <span class="k">return</span> <span class="n">F</span> 
</pre></table></code></div></div><h3 id="7-calculate-transformed-fock-matrix-mathbff"><span class="me-2">7) Calculate Transformed Fock matrix, \(\mathbf{F}’\)</span><a href="#7-calculate-transformed-fock-matrix-mathbff" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Now we have our Fock matrix, we need to apply our transformation matrix, \(\mathbf{X} \equiv \mathbf{S}^{-1/2}\) to calculate the transformed Fock matrix, \(\mathbf{F’}\), but why? We do this to eliminate the overlap matrix from the Roothaan-Hall equations. Consider a new coefficient matrix, \(\mathbf{C}’\) related to the old coefficient matrix, \(\mathbf{C}\) by our transformation matrix, \(\mathbf{X}\)</p><p>\[ \mathbf{C}’= \mathbf{X}^{-1}\mathbf{C} \rightarrow \mathbf{C} = \mathbf{X}\mathbf{C}’. \tag{37} \]</p><p>Substituting \(\mathbf{C} = \mathbf{X}\mathbf{C}’\) into the Roothaan-Hall equations gives</p><p>\[ \mathbf{F}\mathbf{X}\mathbf{C}’ = \mathbf{S}\mathbf{X}\mathbf{C}’\boldsymbol{\epsilon}. \tag{38} \]</p><p>Multiplying on the left by \(\mathbf{X}^\dagger\) gives</p><p>\[ (\mathbf{X}^\dagger\mathbf{F}\mathbf{X})\mathbf{C}’ = (\mathbf{X}^\dagger\mathbf{S}\mathbf{X})\mathbf{C} ‘\boldsymbol{\epsilon}. \tag{39} \]</p><p>If we define a new matrix, \(\mathbf{F}’\) by</p><p>\[ \mathbf{F}’ = \mathbf{X}^\dagger\mathbf{F}\mathbf{X}, \tag{40} \]</p><p>and substitute into equation (39), we are left with</p><p>\[ \mathbf{F}’\mathbf{C}’ = \mathbf{C}’\boldsymbol{\epsilon}, \tag{41} \]</p><p>which are the transformed Roothaan-Hall equations. These do not contain the overlap matrix and can be solved for \(\mathbf{C}’\) by diagonalizing \(\mathbf{F}’\). Given \(\mathbf{C}’\), then \(\mathbf{C}\) can be obtained from equation (37). This allows us to solve the original non-transformed Roothaan-Hall equations given in equation (14).</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Transform Fock matrix to orthonormal Atomic Orbital (AO) basis using transformation matrix, X
    </span><span class="sh">'''</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span> 

<span class="c1"># Calculate F' using fprime function
</span><span class="n">Fprime</span> <span class="o">=</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">S_minhalf</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>          
</pre></table></code></div></div><h3 id="8-diagonalise-mathbff"><span class="me-2">8) Diagonalise \(\mathbf{F}’\)</span><a href="#8-diagonalise-mathbff" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Diagonalising the transformed Fock matrix is done as follows:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1"># Diagonalize F' matrix
# E are eigenvalues of F' matrix
# Cprime are eigenvectors of F' matrix
</span><span class="n">E</span><span class="p">,</span> <span class="n">Cprime</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">eigh</span><span class="p">(</span><span class="n">Fprime</span><span class="p">)</span>      
</pre></table></code></div></div><h3 id="9-calculate-coefficient-matrix-mathbfc--mathbfx-mathbfc"><span class="me-2">9) Calculate Coefficient Matrix \(\mathbf{C} = \mathbf{X} \mathbf{C}’\)</span><a href="#9-calculate-coefficient-matrix-mathbfc--mathbfx-mathbfc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Now we have diagonalized the \(\mathbf{F}’\) matrix to get the \(\mathbf{C}’\) coefficients we need to back-transform these to obtain the coefficients in our original basis. This coefficient matrix is calculated as a product of the transformation matrix and the <code class="language-plaintext highlighter-rouge">Cprime</code> coefficient matrix:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1"># Transform matrix of C' coefficients back into original basis, C, using transformation matrix X
</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">S_minhalf</span><span class="p">,</span> <span class="n">Cprime</span><span class="p">)</span>    
</pre></table></code></div></div><h3 id="10-obtain-new-density-matrix"><span class="me-2">10) Obtain New Density Matrix</span><a href="#10-obtain-new-density-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We now construct the new density matrix using the newly calculated coefficients:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">makedensity</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Nelec</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Make new density matrix and store old one to test for convergence
    </span><span class="sh">'''</span>
    <span class="n">Dold</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="c1"># Initiate zero array
</span>    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">Dold</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">nu</span><span class="p">]</span> <span class="c1"># Set old density matrix to the density matrix, D, input into the function 
</span>            <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">Nelec</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                <span class="c1"># Form new density matrix
</span>                <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">nu</span><span class="p">,</span><span class="n">m</span><span class="p">]</span>

    <span class="c1"># Return both new, D and old, Dold density matrices
</span>    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">Dold</span> 
</pre></table></code></div></div><h3 id="11-determine-convergence"><span class="me-2">11) Determine Convergence</span><a href="#11-determine-convergence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We cannot keep running the Self Consistent Field (SCF) procedure forever, so we need to implement some termination criteria. We will do this using the root mean square deviation which is programmed as follows:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">deltap</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Dold</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Calculate change in density matrix using Root Mean Square Deviation (RMSD)

    D    : Newest density matrix
    Dold : Old density matrix 
    </span><span class="sh">'''</span>
    <span class="n">DELTA</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">DELTA</span> <span class="o">=</span> <span class="n">DELTA</span> <span class="o">+</span> <span class="p">((</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Dold</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nf">return </span><span class="p">(</span><span class="n">DELTA</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="12-repeat-or-end"><span class="me-2">12) Repeat or End</span><a href="#12-repeat-or-end" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To repeat the Self Consistent Field (SCF) procedure we can wrap the above steps in a <code class="language-plaintext highlighter-rouge">while</code> loop and run until convergence is achieved</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">DELTA</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Set placeholder value for convergence
</span>
<span class="k">while</span> <span class="n">DELTA</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
    <span class="c1"># All relevent code segments here. See the complete example below for finished program
</span></pre></table></code></div></div><p>The main reason we are programming Hartree Fock is to calculate the total energy, and this is calculated for each completed SCF cycle using the following function:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">currentenergy</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Hcore</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Calculate energy at iteration 

    D     : Density matrix
    Hcore : Core Hamiltonian matrix
    F     : Fock matrix
    dim   : dimension of problem
    </span><span class="sh">'''</span>
    <span class="n">EN</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">EN</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Hcore</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">EN</span>
</pre></table></code></div></div><h1 id="the-complete-hf-program">The Complete HF Program</h1><p>We can now put all these pieces together into a complete Hartree Fock program, that totals just 100 lines of python code. It can be made even more compact but we want it to be clear and easy to follow.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">symmetrise</span><span class="p">(</span><span class="n">Mat</span><span class="p">):</span> <span class="c1"># Symmetrize a matrix given a triangular one
</span>    <span class="k">return</span> <span class="n">Mat</span> <span class="o">+</span> <span class="n">Mat</span><span class="p">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">diag</span><span class="p">(</span><span class="n">Mat</span><span class="p">.</span><span class="nf">diagonal</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">eint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">):</span> <span class="c1"># Return compound index given four indices using Yoshimine sort
</span>    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">ab</span> <span class="o">&gt;</span> <span class="n">cd</span><span class="p">:</span> <span class="n">abcd</span> <span class="o">=</span> <span class="n">ab</span><span class="o">*</span><span class="p">(</span><span class="n">ab</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cd</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">abcd</span> <span class="o">=</span> <span class="n">cd</span><span class="o">*</span><span class="p">(</span><span class="n">cd</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ab</span>

    <span class="k">return</span> <span class="n">abcd</span>

<span class="k">def</span> <span class="nf">tei</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span> <span class="c1"># Return value of two electron integral
</span>    <span class="k">return</span> <span class="n">twoe</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nf">eint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> 

<span class="k">def</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span> <span class="c1"># Put Fock matrix in orthonormal AO basis
</span>    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">makedensity</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Nelec</span><span class="p">):</span> <span class="c1"># Make density matrix and store old one to test for convergence
</span>    <span class="n">Dold</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">Dold</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">nu</span><span class="p">]</span>
            <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">Nelec</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">nu</span><span class="p">,</span><span class="n">m</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">Dold</span> 

<span class="k">def</span> <span class="nf">makefock</span><span class="p">(</span><span class="n">Hcore</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span> <span class="c1"># Make Fock Matrix
</span>    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hcore</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                    <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nf">tei</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="nf">tei</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">F</span> 

<span class="k">def</span> <span class="nf">deltap</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Dold</span><span class="p">):</span> <span class="c1"># Calculate change in density matrix using Root Mean Square Deviation (RMSD)
</span>    <span class="n">DELTA</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">DELTA</span> <span class="o">=</span> <span class="n">DELTA</span> <span class="o">+</span> <span class="p">((</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Dold</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nf">return </span><span class="p">(</span><span class="n">DELTA</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">currentenergy</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Hcore</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span> <span class="c1"># Calculate energy at iteration
</span>    <span class="n">EN</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">EN</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">D</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Hcore</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">])</span>
            
    <span class="k">return</span> <span class="n">EN</span>

<span class="n">Nelec</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># The number of electrons in our system 
</span><span class="n">ENUC</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="sh">'</span><span class="s">./enuc.dat</span><span class="sh">'</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># ENUC = nuclear repulsion, 
</span><span class="n">Sraw</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="sh">'</span><span class="s">./s.dat</span><span class="sh">'</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>                    <span class="c1"># Sraw is overlap matrix, 
</span><span class="n">Traw</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="sh">'</span><span class="s">./t.dat</span><span class="sh">'</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>                    <span class="c1"># Traw is kinetic energy matrix,
</span><span class="n">Vraw</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="sh">'</span><span class="s">./v.dat</span><span class="sh">'</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>                    <span class="c1"># Vraw is potential energy matrix
</span>
<span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># dim is the number of basis functions 
</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="c1"># Initialize integrals, and put them in a Numpy array
</span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Sraw</span><span class="p">:</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Put the integrals into a matrix 
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Traw</span><span class="p">:</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Put the integrals into a matrix
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Vraw</span><span class="p">:</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Put the integrals into a matrix
</span>
<span class="n">S</span>            <span class="o">=</span> <span class="nf">symmetrise</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="c1"># Flip the triangular matrix in the diagonal 
</span><span class="n">V</span>            <span class="o">=</span> <span class="nf">symmetrise</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="c1"># Flip the triangular matrix in the diagonal
</span><span class="n">T</span>            <span class="o">=</span> <span class="nf">symmetrise</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1"># Flip the triangular matrix in the diagonal
</span><span class="n">TEI</span>          <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="sh">'</span><span class="s">./two_elec_int.dat</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Load two electron integrals
</span><span class="n">twoe</span>         <span class="o">=</span> <span class="p">{</span><span class="nf">eint</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TEI</span><span class="p">}</span> <span class="c1"># Put in python dictionary
</span><span class="n">Hcore</span>        <span class="o">=</span> <span class="n">T</span> <span class="o">+</span> <span class="n">V</span> <span class="c1"># Form core Hamiltonian matrix as sum of one electron kinetic energy, T and potential energy, V matrices
</span><span class="n">SVAL</span><span class="p">,</span> <span class="n">SVEC</span>   <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">eigh</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="c1"># Diagonalize basis using symmetric orthogonalization 
</span><span class="n">SVAL_minhalf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">diag</span><span class="p">(</span><span class="n">SVAL</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)))</span> <span class="c1"># Inverse square root of eigenvalues
</span><span class="n">S_minhalf</span>    <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">SVEC</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">SVAL_minhalf</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">SVEC</span><span class="p">)))</span>
<span class="n">P</span>            <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="c1"># P represents the density matrix, Initially set to zero.
</span><span class="n">DELTA</span>        <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Set placeholder value for delta
</span><span class="n">count</span>        <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Count how many SCF cycles are done, N(SCF)
</span>
<span class="k">while</span> <span class="n">DELTA</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">:</span>
    <span class="n">count</span>     <span class="o">+=</span> <span class="mi">1</span>                             <span class="c1"># Add one to number of SCF cycles counter
</span>    <span class="n">F</span>         <span class="o">=</span> <span class="nf">makefock</span><span class="p">(</span><span class="n">Hcore</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>        <span class="c1"># Calculate Fock matrix, F
</span>    <span class="n">Fprime</span>    <span class="o">=</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">S_minhalf</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>           <span class="c1"># Calculate transformed Fock matrix, F'
</span>    <span class="n">E</span><span class="p">,</span> <span class="n">Cprime</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">eigh</span><span class="p">(</span><span class="n">Fprime</span><span class="p">)</span>         <span class="c1"># Diagonalize F' matrix
</span>    <span class="n">C</span>         <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">S_minhalf</span><span class="p">,</span> <span class="n">Cprime</span><span class="p">)</span>      <span class="c1"># 'Back transform' the coefficients into original basis using transformation matrix
</span>    <span class="n">P</span><span class="p">,</span> <span class="n">OLDP</span>   <span class="o">=</span> <span class="nf">makedensity</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Nelec</span><span class="p">)</span>  <span class="c1"># Make density matrix
</span>    <span class="n">DELTA</span>     <span class="o">=</span> <span class="nf">deltap</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">OLDP</span><span class="p">)</span>                <span class="c1"># Test for convergence. If criteria is met exit loop and calculate properties of interest
</span>    
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">E = {:.6f}, N(SCF) = {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">currentenergy</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Hcore</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">ENUC</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">SCF procedure complete, TOTAL E(SCF) = {} hartrees</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">currentenergy</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Hcore</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">ENUC</span><span class="p">))</span>
</pre></table></code></div></div><p>The output of this program is:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>E = -2.418618, N(SCF) = 2
E = -2.439621, N(SCF) = 3
E = -2.443370, N(SCF) = 4
E = -2.444016, N(SCF) = 5
E = -2.444127, N(SCF) = 6
E = -2.444146, N(SCF) = 7
E = -2.444149, N(SCF) = 8
SCF procedure complete, TOTAL E(SCF) = -2.444149 hartrees
</pre></table></code></div></div><p>This agrees very well with the textbook value of <code class="language-plaintext highlighter-rouge">-2.4438 hartrees</code>\(^{[2]}\) albeit ours is more accurate, probably due to a stricter tolerance for convergence.</p><h1 id="conclusions">Conclusions</h1><p>We have given a simple overview of Hartree Fock theory and then expanded upon the key components in order to create our own 100 line Hartree Fock program. We used protonated helium as our test case and obtained a ground state energy of <code class="language-plaintext highlighter-rouge">-2.44414 hartrees</code> which matches very well to literature. If there are still parts of the process which are not clear, you can <code class="language-plaintext highlighter-rouge">print()</code> out as much information as needed from this program to follow each step in greater detail.</p><h1 id="further-reading">Further Reading</h1><p>If you want to explore Hartree Fock theory in even greater detail then I highly recommend the book by <strong>Szabo and Ostlund</strong>. It is very technical but is the best book on Hartree Fock theory:</p><p>1) <a href="https://www.amazon.co.uk/Modern-Quantum-Chemistry-Introduction-Electronic/dp/0486691861">Modern Quantum Chemistry: Introduction to Advanced Electronic Structure</a></p><p>I also recommend the textbook by <strong>Lewars</strong> if you want a more gentle introduction:</p><p>2) <a href="https://www.amazon.co.uk/Computational-Chemistry-Introduction-Applications-Molecular/dp/3319309145/ref=sr_1_1?dchild=1&amp;keywords=lewars&amp;qid=1586781963&amp;s=books&amp;sr=1-1">Computational Chemistry: Introduction to the Theory and Applications of Molecular and Quantum Mechanics</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/science/" class="post-tag no-text-decoration" >Science</a> <a href="/tags/mathematics/" class="post-tag no-text-decoration" >Mathematics</a> <a href="/tags/programming/" class="post-tag no-text-decoration" >Programming</a> <a href="/tags/hartree-fock/" class="post-tag no-text-decoration" >Hartree Fock</a> <a href="/tags/scf/" class="post-tag no-text-decoration" >SCF</a> <a href="/tags/electron-correlation/" class="post-tag no-text-decoration" >electron correlation</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=T%3ET:%20Hartree%20Fock%20Theory%20in%20100%20Lines%20-%20Dr%20Adam%20Luke%20Baskerville&url=https%3A%2F%2Fadambaskerville.github.io%2Fposts%2FHartreeFockGuide%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=T%3ET:%20Hartree%20Fock%20Theory%20in%20100%20Lines%20-%20Dr%20Adam%20Luke%20Baskerville&u=https%3A%2F%2Fadambaskerville.github.io%2Fposts%2FHartreeFockGuide%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fadambaskerville.github.io%2Fposts%2FHartreeFockGuide%2F&text=T%3ET:%20Hartree%20Fock%20Theory%20in%20100%20Lines%20-%20Dr%20Adam%20Luke%20Baskerville" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/am1bcc_speedup/">T>T: Turbocharging AM1BCC Charge Calculations</a><li class="text-truncate lh-lg"> <a href="/posts/BuffonNeedle/">T>T: Buffon's Needle: Estimating π using Toothpicks</a><li class="text-truncate lh-lg"> <a href="/posts/HighPrecisionEigenvalues/">T>T: High-Precision Eigenvalue Computations Made Efficient in C++</a><li class="text-truncate lh-lg"> <a href="/posts/DearpyguiCompilation/">T>T: Compiling DearPyGui on Raspberry Pi 32-bit OS</a><li class="text-truncate lh-lg"> <a href="/posts/Introduction-post/">T>T: Introduction</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/mathematics/">mathematics</a> <a class="post-tag btn btn-outline-primary" href="/tags/science/">science</a> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/mathematics/">Mathematics</a> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">Programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/science/">Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a> <a class="post-tag btn btn-outline-primary" href="/tags/chemistry/">chemistry</a> <a class="post-tag btn btn-outline-primary" href="/tags/matplotlib/">matplotlib</a> <a class="post-tag btn btn-outline-primary" href="/tags/length/">length</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Variational-Method-Hydrogen/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1579132800" data-df="ll" > Jan 16, 2020 </time><h4 class="pt-0 my-2">T>T: Solving the Hydrogen Atom Variationally</h4><div class="text-muted"><p>Try the code yourself! Click the following button to launch an ipython notebook on Google Colab which implements the code developed in this post: The Problem: We want to solve the Schrödinger ...</p></div></div></a></article><article class="col"> <a href="/posts/LespEigenvalues/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1575244800" data-df="ll" > Dec 2, 2019 </time><h4 class="pt-0 my-2">T>T: When Double Precision is Not Enough</h4><div class="text-muted"><p>Try the code yourself! Click the following button to launch an ipython notebook on Google Colab which implements the code developed in this post: The Problem: We want to solve the following st...</p></div></div></a></article><article class="col"> <a href="/posts/PythonSubprocess/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1567033200" data-df="ll" > Aug 29, 2019 </time><h4 class="pt-0 my-2">T>T: Call C++ From Python Without Wrapping</h4><div class="text-muted"><p>The Problem: We want to programmatically find the minimum value of the following simple function \[ f(x,y) = x^2 + y^2 + 3 \tag{1} \] We already know the answer to this, \(\text{min}(f(x,y)) = ...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Variational-Method-Hydrogen/" class="btn btn-outline-primary" aria-label="Older" ><p>T>T: Solving the Hydrogen Atom Variationally</p></a> <a href="/posts/PythonGUIPlotter/" class="btn btn-outline-primary" aria-label="Newer" ><p>T>T: Simple GUI Graph Plotter in Python</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/SciBaskerville">Adam Baskerville</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.0" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/mathematics/">mathematics</a> <a class="post-tag btn btn-outline-primary" href="/tags/science/">science</a> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/mathematics/">Mathematics</a> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">Programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/science/">Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a> <a class="post-tag btn btn-outline-primary" href="/tags/chemistry/">chemistry</a> <a class="post-tag btn btn-outline-primary" href="/tags/matplotlib/">matplotlib</a> <a class="post-tag btn btn-outline-primary" href="/tags/length/">length</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
